"use strict";(self.webpackChunkreact_cmu_docs_2024=self.webpackChunkreact_cmu_docs_2024||[]).push([[2782],{6981:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=n(4848),o=n(8453);const i={sidebar_position:4},r="Unit Testing",a={id:"tutorial-extras/unit-testing",title:"Unit Testing",description:"Ensure our component/function/hooks working correctly also it can throw error or give us feedback when it was changed.",source:"@site/docs/tutorial-extras/unit-testing.md",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/unit-testing",permalink:"/mycos-workshop-2024/docs/tutorial-extras/unit-testing",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Design Pattern",permalink:"/mycos-workshop-2024/docs/tutorial-extras/design-pattern"}},c={},l=[{value:"Contents",id:"contents",level:2},{value:"Tools",id:"tools",level:2},{value:"Keywords",id:"keywords",level:2},{value:"Test Case",id:"test-case",level:2},{value:"Test Doubles",id:"test-doubles",level:2},{value:"UI Testing",id:"ui-testing",level:2},{value:"Snapshot Test",id:"snapshot-test",level:3},{value:"Test with Render Screen",id:"test-with-render-screen",level:3},{value:"Test Fire Event",id:"test-fire-event",level:3},{value:"debug UI",id:"debug-ui",level:3},{value:"Test Async UI",id:"test-async-ui",level:3},{value:"Query Element",id:"query-element",level:3},{value:"Single Elements",id:"single-elements",level:4},{value:"Multiple Elements",id:"multiple-elements",level:4},{value:"struck how to find element or element too complicated",id:"struck-how-to-find-element-or-element-too-complicated",level:4},{value:"Hook Test",id:"hook-test",level:2},{value:"Test Normal Hook",id:"test-normal-hook",level:3},{value:"Test Async Hook",id:"test-async-hook",level:3},{value:"Test Component by mock Hook",id:"test-component-by-mock-hook",level:3}];function d(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"unit-testing",children:"Unit Testing"})}),"\n",(0,s.jsx)(e.p,{children:"Ensure our component/function/hooks working correctly also it can throw error or give us feedback when it was changed."}),"\n",(0,s.jsx)(e.h2,{id:"contents",children:"Contents"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#tools",children:"Tools"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#keywords",children:"Keywords"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-case",children:"Test Case"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-doubles",children:"Test Doubles"})}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"#ui-testing",children:"UI Testing"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#snapshot-test",children:"Snapshot Test"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-with-render-screen",children:"Test with Render Screen"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-fire-event",children:"Test Fire Event"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#debug-ui",children:"debug UI"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-async-ui",children:"Test Async UI"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"#hook-test",children:"Hook Test"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-normal-hook",children:"Test Normal Hook"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-async-hook",children:"Test Async Hook"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#test-component-by-mock-hook",children:"Test Component by mock Hook"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"tools",children:"Tools"}),"\n",(0,s.jsxs)(e.p,{children:["Since this project created by ",(0,s.jsx)(e.code,{children:"vite"})," so, we will use ",(0,s.jsx)(e.code,{children:"vitest"})," and ",(0,s.jsx)(e.code,{children:"@testing-library/react"})]}),"\n",(0,s.jsx)(e.p,{children:"all packages installed"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"@testing-library/jest-dom\n\n@testing-library/react\n\njsdom\n\nvitest\n"})}),"\n",(0,s.jsxs)(e.p,{children:["then, config in ",(0,s.jsx)(e.code,{children:"viteConfig"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/* vite.config.ts */\n\n/// <reference types=\"vitest\" />\n\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: './src/config/setupTest.ts'\n  }\n})\n\n/* src/config/setupTest.ts */\nimport '@testing-library/jest-dom'\n\n"})}),"\n",(0,s.jsx)(e.h2,{id:"keywords",children:"Keywords"}),"\n",(0,s.jsx)(e.p,{children:"Wording in unit-testing field, may have another depends on Programming Language/ Framework etc..."}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Test framework"})," (we use @testing-library/react)-> contain tools, helper for testing a component/function"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Test Runner"})," (we use vitest) -> Can compile Test, build test like complier in programming language"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Test Case"})," -> every case situation in function/component/class other..."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Test Doubles"})," -> Simulate/Mock dependency of focus test which not call the real method."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Coverage"})," -> measure does implemented test reach over covering code/condition to percentage"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"File name"})," it depends Test Runner or Config, like we should name extension with ",(0,s.jsx)(e.code,{children:".test.ts"})," or ",(0,s.jsx)(e.code,{children:".spec.ts"})," .\nOther all tests stored in folder ",(0,s.jsx)(e.code,{children:"__tests__"})," etc."]}),"\n",(0,s.jsx)(e.p,{children:'unit-testing in React, contains scope(describe) and test case(it(""), or test(""))'}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Scope"})," -> group multiple relate test cases, scope can be nested."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'describe("useThaiWin", () => {\n\ttest("1")\n\ttest("2")\n\ttest("3")\n\ttest("4")\n})\n\n    describe("calculator", () => {\n        describe("minus", () => { ... })\n        describe("plus", () => { ... })\n        describe("multiply", () => { ... })\n    })\n'})}),"\n",(0,s.jsx)(e.h2,{id:"test-case",children:"Test Case"}),"\n",(0,s.jsx)(e.p,{children:"Good unit-testing should be;"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Each test is solid separately"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"One test-case, One problem"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["name the test with pattern ",(0,s.jsx)(e.code,{children:"Test, when should"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["mostly contains these sections ",(0,s.jsx)(e.code,{children:"Arrange"}),", ",(0,s.jsx)(e.code,{children:"Act"}),", ",(0,s.jsx)(e.code,{children:"Assert"}),", ",(0,s.jsx)(e.code,{children:"Clean"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'test("cal multiply when a is 5 and b is 6 should be 30", () => {\n\t// Arrange -> prepare minimum requirement for component\n\t// Act -> Scenario for testing that we expected\n\t// Assert -> expect result that we expected\n\t// Clean -> optional if we need to reset something before go to other test case\n})\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"example"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'const calMultiply = (a, b) => {\n\treturn a * b\n}\n\ntest("calMultiply when a is 5 and b is 6 should be 30", () => {\n\t// Arrange\n\tconst a = 5\n\tconst b = 6\n\tconst expectResult = 30\n\n\t// Act\n\tconst result = calMultiply(a, b)\n\n\t// Assert\n\texpect(result).toEqual(expectResult)\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"if we want to add divine operation, so we need to add new test case for divine, luckily we set default isDivine false so we don't need to update the first test case"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'const calMultiplyAndDivine = (a, b, isDivine: boolean = false) => {\n\tif (isDivine) {\n\t\treturn a / b\n\t}\n\n\treturn a * b\n}\n\ndescribe("calMultiplyAndDivine", () => {\n\ttest("calMultiply when a is 5 and b is 6 should be 30", () => {\n\t\t// Arrange\n\t\tconst a = 5\n\t\tconst b = 6\n\t\tconst expectResult = 30\n\n\t\t// Act\n\t\tconst result = calMultiply(a, b)\n\n\t\t// Assert\n\t\texpect(result).toEqual(expectResult)\n\t})\n\n\ttest("calMultiply with divine when a is 30 and b is 5 should be 6", () => {\n\t\t// Arrange\n\t\tconst a = 30\n\t\tconst b = 5\n\t\tconst expectResult = 6\n\n\t\t// Act\n\t\tconst result = calMultiply(a, b, true)\n\n\t\t// Assert\n\t\texpect(result).toEqual(expectResult)\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"but number cannot divine by zero, so we should add condition and test for this case"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'const calMultiplyAndDivine = (a, b, isDivine: boolean = false) => {\n\tif (isDivine) {\n\t\tif (b === 0) {\n\t\t\tthrow new Error("b cannot be 0")\n\t\t}\n\n\t\treturn a / b\n\t}\n\n\treturn a * b\n}\n\ntest("divine when b = 0 should got error `b cannot be 0`", () => {\n\t// Arrange\n\tconst a = 5\n\tconst b = 0\n\tconst expectResult = "b cannot be 0"\n\n\t// Act & Assert\n\texpect(() => calculator(a, b, true)).toThrowError(expectResult)\n})\n'})}),"\n",(0,s.jsxs)(e.p,{children:["if we want to add plus operation, we can modify like change ",(0,s.jsx)(e.code,{children:"isDivine"})," to multiple type or enum, then we change old test cases too"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// good idea to rename function to calculator\nconst calculator = (\n\ta: number,\n\tb: number,\n\toperation: "plus" | "divine" | "multiply" = "multiply"\n) => {\n\tif (operation === "divine") {\n\t\tif (b === 0) {\n\t\t\tthrow new Error("b cannot be 0")\n\t\t}\n\n\t\treturn a / b\n\t} else if (operation === "plus") {\n\t\treturn a + b\n\t}\n\n\treturn a * b\n}\n\ndescribe("calculator", () => {\n\ttest("multiply when a is 5 and b is 6 should be 30", () => {\n\t\t// Arrange\n\t\tconst a = 5\n\t\tconst b = 6\n\t\tconst expectResult = 30\n\n\t\t// Act\n\t\tconst result = calMultiply(a, b)\n\n\t\t// Assert\n\t\texpect(result).toEqual(expectResult)\n\t})\n\n\ttest("divine when a is 30 and b is 5 should be 6", () => {\n\t\t// Arrange\n\t\tconst a = 30\n\t\tconst b = 5\n\t\tconst expectResult = 6\n\n\t\t// Act\n\t\tconst result = calMultiply(a, b, "divine")\n\n\t\t// Assert\n\t\texpect(result).toEqual(expectResult)\n\t})\n\n\ttest("divine when b = 0 should got error `b cannot be 0`", () => {\n\t\t// Arrange\n\t\tconst a = 5\n\t\tconst b = 0\n\t\tconst expectResult = "b cannot be 0"\n\n\t\t// Act & Assert\n\t\texpect(() => calculator(a, b, "divine")).toThrowError(expectResult)\n\t})\n\n\ttest("plus when b = 11, a = 22 should be 33", () => {\n\t\t// Arrange\n\t\tconst a = 11\n\t\tconst b = 22\n\t\tconst expectResult = 33\n\n\t\t// Act\n\t\tconst result = calMultiply(a, b, "plus")\n\n\t\t// Assert\n\t\texpect(result).toEqual(expectResult)\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"but good function should work one method right?\nso we can refactor"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'//operation.ts\nexport const plusOperation = (a: number, b: number): number => a + b\n\nexport const divineOperation = (a: number, b: number): number => {\n\tif (b === 0) {\n\t\tthrow new Error("b cannot be 0")\n\t}\n\n\treturn a / b\n}\n\nexport const multiplyOperation = (a: number, b: number): number => a * b\n\n// calculator.ts\nimport { divineOperation, multiplyOperation, plusOperation } from "./operation"\n\nexport const calculator = (\n\ta: number,\n\tb: number,\n\toperation: "plus" | "divine" | "multiply" = "multiply"\n) => {\n\tif (operation === "divine") {\n\t\treturn divineOperation(a, b)\n\t} else if (operation === "plus") {\n\t\treturn plusOperation(a, b)\n\t}\n\n\treturn multiplyOperation(a, b)\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["then, refactor test which move logic to ",(0,s.jsx)(e.code,{children:"operation.test.ts"})," instead"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { divineOperation, multiplyOperation, plusOperation } from "./operation"\n\ndescribe("operation", () => {\n\tdescribe("divineOperation", () => {\n\t\ttest("a is 30 and b is 5 should be 6", () => {\n\t\t\t// Arrange\n\t\t\tconst a = 30\n\t\t\tconst b = 6\n\t\t\tconst expectResult = 5\n\n\t\t\t// Act\n\t\t\tconst result = divineOperation(a, b)\n\n\t\t\t// Assert\n\t\t\texpect(result).toEqual(expectResult)\n\t\t})\n\n\t\ttest("b = 0 should got error `b cannot be 0`", () => {\n\t\t\t// Arrange\n\t\t\tconst a = 5\n\t\t\tconst b = 0\n\t\t\tconst expectResult = "b cannot be 0"\n\n\t\t\t// Act & Assert\n\t\t\texpect(() => divineOperation(a, b)).toThrowError(expectResult)\n\t\t})\n\t})\n\n\tdescribe("plusOperation", () => {\n\t\ttest("plus when b = 11, a = 22 should be 33", () => {\n\t\t\t// Arrange\n\t\t\tconst a = 11\n\t\t\tconst b = 22\n\t\t\tconst expectResult = 33\n\n\t\t\t// Act\n\t\t\tconst result = plusOperation(a, b)\n\n\t\t\t// Assert\n\t\t\texpect(result).toEqual(expectResult)\n\t\t})\n\t})\n\n\tdescribe("multiplyOperation", () => {\n\t\ttest("multiply when a is 5 and b is 6 should be 30", () => {\n\t\t\t// Arrange\n\t\t\tconst a = 5\n\t\t\tconst b = 6\n\t\t\tconst expectResult = 30\n\n\t\t\t// Act\n\t\t\tconst result = multiplyOperation(a, b)\n\n\t\t\t// Assert\n\t\t\texpect(result).toEqual(expectResult)\n\t\t})\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"What about calculator function? how to test it?"}),"\n",(0,s.jsx)(e.h2,{id:"test-doubles",children:"Test Doubles"}),"\n",(0,s.jsx)(e.p,{children:"We can simulate dependencies of function which not to call actual like call API we just fake call not real call API especially in Unit-testing which need to separately.\nExample method (but it call difference depend of Test Framework)"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Stub, simplest; They are typically used to replace a method that returns a value that is needed for the test or just make minimum dependency of function to make it pass."}),"\n",(0,s.jsx)(e.li,{children:"Spies, Record information about how they were called, such as the number of times called, the arguments with which they were called, etc."}),"\n",(0,s.jsx)(e.li,{children:"Mocks or Fakes, re-implementation that dependencies to make sure it suite our test case e.g. change database stored in memory (Dependency Injection is the good example since we communicate with interface only, so we can implemented with the same interface)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["But we use ",(0,s.jsx)(e.code,{children:"Vitest"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"vi.spyOn"})," it combine Stub and Spies mean it can just tracking called without call a real function also, can mock return or mock implementation"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { calculator } from "./calculator"\n// spyOn API accept params with (object, method) so we wrap all export to one object call operation\nimport * as operation from "./operation"\n\ndescribe("calculator", () => {\n\ttest("input plus should called plusOperation", () => {\n\t\t// Arrange\n\t\tconst spyPlus = vi.spyOn(operation, "plusOperation")\n\t\tconst spyDivine = vi.spyOn(operation, "divineOperation")\n\n\t\tconst a = 5\n\t\tconst b = 6\n\n\t\t// Act\n\t\tcalculator(a, b, "plus")\n\n\t\t// Assert\n\t\texpect(spyPlus).toHaveBeenCalledOnce()\n\t\texpect(spyPlus).toHaveBeenCalledWith(a, b)\n\t\texpect(spyDivine).not.toHaveBeenCalled()\n\n\t\t// Clean up\n\t\tvi.restoreAllMocks()\n\t})\n})\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"vi.mock"}),"\nMock all root file"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { calculator } from "./calculator"\nimport { plusOperation, divineOperation, multiplyOperation } from "./operation"\n\nvi.mock("./operation.ts", () => ({\n\tplusOperation: vi.fn(),\n\tdivineOperation: vi.fn(),\n\tmultiplyOperation: vi.fn(),\n}))\n\ndescribe("calculator", () => {\n\ttest("input plus should called plusOperation", () => {\n\t\t// Arrange\n\t\tconst a = 5\n\t\tconst b = 6\n\n\t\t// Act\n\t\tcalculator(a, b, "plus")\n\n\t\t// Assert\n\t\texpect(plusOperation).toHaveBeenCalledOnce()\n\t\texpect(plusOperation).toHaveBeenCalledWith(a, b)\n\t\texpect(divineOperation).not.toHaveBeenCalled()\n\n\t\t// Clean up\n\t\tvi.resetAllMocks()\n\t})\n\n\ttest("input multiply should called multiplyOperation", () => {\n\t\t// Arrange\n\n\t\tconst a = 5\n\t\tconst b = 6\n\n\t\t// Act\n\t\tcalculator(a, b, "multiply")\n\n\t\t// Assert\n\t\texpect(multiplyOperation).toHaveBeenCalledOnce()\n\t\texpect(multiplyOperation).toHaveBeenCalledWith(a, b)\n\t\texpect(divineOperation).not.toHaveBeenCalled()\n\n\t\t// Clean up\n\t\tvi.resetAllMocks()\n\t})\n})\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Read more: ",(0,s.jsx)(e.a,{href:"https://vitest.dev/guide/mocking.html",children:"https://vitest.dev/guide/mocking.html"})]}),"\n",(0,s.jsx)(e.h2,{id:"ui-testing",children:"UI Testing"}),"\n",(0,s.jsxs)(e.p,{children:["In Presentation component we show some view and we make sure it show as we expected\nIt have many third party help react test, now we ",(0,s.jsx)(e.code,{children:'@testing-library/react"'})]}),"\n",(0,s.jsx)(e.h3,{id:"snapshot-test",children:"Snapshot Test"}),"\n",(0,s.jsx)(e.p,{children:"we save latest change of the component, if some one edit the file accidentally it will throw error"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import MainContent from "./MainContent"\n\ndescribe("MainContent", () => {\n\ttest("snapshot", () => {\n\t\texpect(MainContent()).toMatchSnapshot()\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"or we need to update more latest version of component\nwe use can"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"npx vitest -u\n// or\nnpx vitest --update\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"test-with-render-screen",children:"Test with Render Screen"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// ContentLoaded.tsx\nconst ContentLoaded = ({ isFinished }: { isFinished: boolean }) => {\n\treturn (\n\t\t<div>\n\t\t\t{isFinished ? <h1>Content Finished</h1> : <h1>Content Loading</h1>}\n\t\t</div>\n\t)\n}\n\nexport default ContentLoaded\n\n// ContentLoaded.test.tsx\nimport { render, screen } from "@testing-library/react"\nimport ContentLoaded from "./ContentLoaded"\n\ndescribe("ContentLoaded", () => {\n\ttest("isFinished is true should show `Content Finished`", async () => {\n\t\t// Arrange\n\t\tconst isFinished = true\n\t\trender(<ContentLoaded isFinished={isFinished} />)\n\n\t\t// Act\n\t\tawait screen.findByRole("heading")\n\n\t\t// Assert\n\t\texpect(screen.getByRole("heading")).toHaveTextContent("Content Finished")\n\t})\n\n\ttest("isFinished is false should show `Content Loading`", async () => {\n\t\t// Arrange\n\t\tconst isFinished = false\n\t\trender(<ContentLoaded isFinished={isFinished} />)\n\n\t\t// Act\n\t\tawait screen.findByRole("heading")\n\n\t\t// Assert\n\t\texpect(screen.getByRole("heading")).toHaveTextContent("Content Loading")\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.h3,{id:"test-fire-event",children:"Test Fire Event"}),"\n",(0,s.jsx)(e.p,{children:"in UI obviously we have do some event to HTML element like click a button"}),"\n",(0,s.jsx)(e.p,{children:"example click to change view on Component"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// ContentLoaded.tsx\nconst ContentLoaded = () => {\n\tconst [isFinished, setIsFinished] = useState(true)\n\tconst onClickButton = () => {\n\t\tsetIsFinished(prev => !prev)\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<button onClick={onClickButton}>toggle</button>\n\t\t\t{isFinished ? <h1>Content Finished</h1> : <h1>Content Loading</h1>}\n\t\t\t<input >\n\t\t</div>\n\t)\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["For testing we will use ",(0,s.jsx)(e.code,{children:"fireEvent"})," API from ",(0,s.jsx)(e.code,{children:"@testing-library/react"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'\n...\ntest("first click toggle should show content loading", () => {\n\t// Arrange\n\trender(<ContentLoaded />)\n\n\t// Act\n\tconst button = screen.getByRole("button")\n\tfireEvent.click(button)\n\n\t// Assert\n\texpect(screen.getByText("Content Loading")).toBeInTheDocument()\n})\n'})}),"\n",(0,s.jsx)(e.p,{children:"If we have input, mostly input will fire 'change' event"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// ContentLoaded.tsx\n...\n<label htmlFor="username-input">Username</label>\n<input id="username-input" />\n\n\n// test\ntest("input `buy something` the input should have value", async () => {\n        // Arrange\n        const valueExpect = "buy something"\n        render(<ContentLoaded />)\n\n        // Act\n        const inputNode = screen.getByLabelText(\'Username\')\n\n\n        fireEvent.change(inputNode, { target : { value: valueExpect } })\n\n        // Assert\n        expect(inputNode.value).toEqual(valueExpect)\n    })\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"debug-ui",children:"debug UI"}),"\n",(0,s.jsxs)(e.p,{children:["While implementing test use ",(0,s.jsx)(e.code,{children:"screen.debug()"})," after render a component"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { render, screen } from "@testing-library/react"\n\nscreen.debug()\n'})}),"\n",(0,s.jsx)(e.h3,{id:"test-async-ui",children:"Test Async UI"}),"\n",(0,s.jsxs)(e.p,{children:["Example we delay the change Content Loading a Component with ",(0,s.jsx)(e.code,{children:"setTimeout"})," How do we test this?\na way method, vitest provide ",(0,s.jsx)(e.code,{children:"vi.useFakeTimers()"})," for faking time and we should clean up with ",(0,s.jsx)(e.code,{children:"vi.useRealTimers()"})," since we wait 5000 ms, so we fake it pass 5000 ms in ",(0,s.jsx)(e.code,{children:"act"}),", act from ",(0,s.jsx)(e.code,{children:"@testing-library/react"})," used for detected latest change of the component."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'const ContentLoaded = () => {\n\tconst [isFinished, setIsFinished] = useState(true)\n\n\tconst onClickButton = () => {\n\t\tsetTimeout(() => {\n\t\t\tsetIsFinished((prev) => !prev)\n\t\t}, 5000)\n\t}\n\n\treturn (\n\t\t<div>\n\t\t\t<button onClick={onClickButton}>toggle</button>\n\t\t\t{isFinished ? <h1>Content Finished</h1> : <h1>Content Loading</h1>}\n\t\t</div>\n\t)\n}\n\n// test\ntest("first click toggle after time fly 3000 ms, should still show `content Finished`", () => {\n\t// Arrange\n\tvi.useFakeTimers()\n\trender(<ContentLoaded />)\n\n\t// Act\n\tconst button = screen.getByRole("button")\n\tfireEvent.click(button)\n\tact(() => {\n\t\tvi.advanceTimersByTime(3000)\n\t})\n\n\t// Assert\n\texpect(screen.getByText("Content Finished")).toBeInTheDocument()\n\n\t// Clean up\n\tvi.useRealTimers()\n})\n\ntest("first click toggle after time fly 5000 ms, should show `content loading`", () => {\n\t// Arrange\n\tvi.useFakeTimers()\n\trender(<ContentLoaded />)\n\n\t// Act\n\tconst button = screen.getByRole("button")\n\tfireEvent.click(button)\n\tact(() => {\n\t\tvi.advanceTimersByTime(5000)\n\t})\n\n\t// Assert\n\texpect(screen.getByText("Content Loading")).toBeInTheDocument()\n\n\t// Clean up\n\tvi.useRealTimers()\n})\n'})}),"\n",(0,s.jsx)(e.h3,{id:"query-element",children:"Query Element"}),"\n",(0,s.jsx)(e.p,{children:"React testing library has api for getting or querying element while we write unit-testing"}),"\n",(0,s.jsx)(e.h4,{id:"single-elements",children:"Single Elements"}),"\n",(0,s.jsx)(e.p,{children:"getBy...: Returns the matching node for a query, and throw a descriptive error if no elements match or if more than one match is found."}),"\n",(0,s.jsx)(e.p,{children:"queryBy...: Returns the matching node for a query, and return null if no elements match. This is useful for asserting an element that is not present. Throws an error if more than one match is found."}),"\n",(0,s.jsx)(e.p,{children:"findBy...: Returns a Promise which resolves when an element is found which matches the given query. The promise is rejected if no element is found or if more than one element is found after a default timeout of 1000ms."}),"\n",(0,s.jsx)(e.h4,{id:"multiple-elements",children:"Multiple Elements"}),"\n",(0,s.jsx)(e.p,{children:"getAllBy...: Returns an array of all matching nodes for a query, and throws an error if no elements match."}),"\n",(0,s.jsx)(e.p,{children:"queryAllBy...: Returns an array of all matching nodes for a query, and return an empty array ([]) if no elements match."}),"\n",(0,s.jsx)(e.p,{children:"findAllBy...: Returns a promise which resolves to an array of elements when any elements are found which match the given query. The promise is rejected if no elements are found after a default timeout of 1000ms.\nfindBy methods are a combination of getBy* queries and waitFor. They accept the waitFor options as the last argument (i.e. await screen.findByText('text', queryOptions, waitForOptions))"}),"\n",(0,s.jsx)(e.h4,{id:"struck-how-to-find-element-or-element-too-complicated",children:"struck how to find element or element too complicated"}),"\n",(0,s.jsxs)(e.p,{children:["we can manually add ",(0,s.jsx)(e.code,{children:"data-testid"})," to element and get with ",(0,s.jsx)(e.code,{children:"findByTestId"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'<div data-testid="test-id-purpose" />\n\n...\n\nscreen.findByTestId("test-id-purpose")\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Read more API: ",(0,s.jsx)(e.a,{href:"https://testing-library.com/docs/react-testing-library/intro",children:"https://testing-library.com/docs/react-testing-library/intro"})]}),"\n",(0,s.jsx)(e.h2,{id:"hook-test",children:"Hook Test"}),"\n",(0,s.jsx)(e.p,{children:"We can test the hook too, hook is the best way to separate logic out from UI that why we can test with isolation from UI"}),"\n",(0,s.jsx)(e.h3,{id:"test-normal-hook",children:"Test Normal Hook"}),"\n",(0,s.jsxs)(e.p,{children:["The '@testing-library/react' package provide API ",(0,s.jsx)(e.code,{children:"renderHook"})," for us to be able to write test for our hooks."]}),"\n",(0,s.jsx)(e.p,{children:"Example we have useSearchTodo."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// useSearchTodo.ts\nimport { useState, useMemo } from "react"\n\nconst useSearchTodo = (todos: ITodo[]) => {\n\tconst [searchTerm, setSearchTerm] = useState("")\n\tconst filteredTodos = useMemo(\n\t\t() =>\n\t\t\ttodos.filter((todo) =>\n\t\t\t\ttodo.title.toLowerCase().includes(searchTerm.toLowerCase())\n\t\t\t),\n\t\t[todos, searchTerm]\n\t)\n\n\treturn {\n\t\tsearchTerm,\n\t\tsetSearchTerm,\n\t\tfilteredTodos,\n\t}\n}\n\nexport default useSearchTodo\n'})}),"\n",(0,s.jsx)(e.p,{children:"Good start with when initial hook scenario"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// useSearchTodo.test.ts\nimport { renderHook } from "@testing-library/react"\nimport useSearchTodo from "./useSearchTodo"\n\ndescribe("useSearchTodo", () => {\n\ttest("when initial, return a default search term and original todos", () => {\n\t\t// Arrange\n\t\tconst todos = [{ title: "Buy Stellar Blade game", completed: false }]\n\t\tconst { result } = renderHook(() => useSearchTodo(todos))\n\n\t\t// Act & Assert\n\t\texpect(result.current.searchTerm).toBe("")\n\t\texpect(result.current.filteredTodos).toEqual(todos)\n\t})\n})\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"RenderHook"})," return many Object, one for this case it return ",(0,s.jsx)(e.code,{children:"result"})," which we destructing on above, and all returned from hook it contain at ",(0,s.jsx)(e.code,{children:"current"})," of ",(0,s.jsx)(e.code,{children:"result"})," object or ",(0,s.jsx)(e.code,{children:"result.current"})]}),"\n",(0,s.jsxs)(e.p,{children:["add another test-case, we want to test set a search term\nwe want to re-render hook since hook state it-self changed, we can use ",(0,s.jsx)(e.code,{children:"act"})," API from ReactTesting Library"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"...\ntest('when search with `Buy` should return `Buy Stellar Blade game` only', () => {\n\t\t// Arrange\n        const todos = [\n            { title: 'Buy Stellar Blade game', completed: false },\n            { title: 'Finish the Task 339', completed: false }\n        ]\n        const { result } = renderHook(() => useSearchTodo(todos))\n\n\t\t// Act\n        act(() => {\n            result.current.setSearchTerm('Buy')\n        })\n\n\t\t// Assert\n        expect(result.current.searchTerm).toBe('Buy')\n        expect(result.current.filteredTodos).toEqual([{ title: 'Buy Stellar Blade game', completed: false }])\n})\n"})}),"\n",(0,s.jsx)(e.h3,{id:"test-async-hook",children:"Test Async Hook"}),"\n",(0,s.jsx)(e.p,{children:"example test custom hook that get a data from api"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// useFetchTodo.ts\nimport { useEffect, useState } from "react"\nimport { fetchTodoUser } from "../api/weWinApi"\n\nconst useFetchTodo = () => {\n\tconst [todos, setTodos] = useState([])\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\tconst fetchTodo = async () => {\n\t\ttry {\n\t\t\tsetIsLoading(true)\n\t\t\tconst results = await fetchTodoUser()\n\n\t\t\tsetTodos(results)\n\t\t} catch (err) {\n\t\t} finally {\n\t\t\tsetIsLoading(false)\n\t\t}\n\t}\n\n\tuseEffect(() => {\n\t\tfetchTodo()\n\t}, [])\n\n\treturn { todos, isLoading }\n}\n\nexport default useFetchTodo\n'})}),"\n",(0,s.jsxs)(e.p,{children:["Testing Library provide waitFor to handle async\nalso, we mock fetchTodo with vi.spyOn from ",(0,s.jsx)(e.code,{children:"vitest"})," since unit-testing we don't want to fetch a real one"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { renderHook, waitFor } from "@testing-library/react"\nimport useFetchTodo from "./useFetchTodo"\nimport * as api from "../api/weWinApi"\n\ndescribe("useFetchTodo", () => {\n\ttest("when init should called once fetch todo api and return todos, isLoading", async () => {\n\t\t// Arrange\n\t\tconst spyTodoApi = vi.spyOn(api, "fetchTodoUser").mockResolvedValue([\n\t\t\t{\n\t\t\t\ttitle: "Buy Stellar Blade game",\n\t\t\t\tcompleted: true,\n\t\t\t},\n\t\t])\n\n\t\tconst { result } = renderHook(() => useFetchTodo())\n\n\t\t// Act & Assert\n\t\tawait waitFor(() => {\n\t\t\texpect(result.current.todos).toEqual([])\n\t\t\texpect(result.current.isLoading).toEqual(false)\n\t\t})\n\t\texpect(spyTodoApi).toBeCalledTimes(1)\n\n\t\t// Reset\n\t\tspyTodoApi.mockRestore()\n\t})\n})\n'})}),"\n",(0,s.jsx)(e.h3,{id:"test-component-by-mock-hook",children:"Test Component by mock Hook"}),"\n",(0,s.jsx)(e.p,{children:"Sometime we want to test component but component have to used complicated hook inside, a way just mock the hook"}),"\n",(0,s.jsx)(e.p,{children:"Example fetchTodo to List"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// TodoList.tsx\nimport useFetchTodo from "../../hooks/useFetchTodo/useFetchTodo"\n\nconst TodoList = () => {\n\tconst { isLoading, todos } = useFetchTodo()\n\n\treturn (\n\t\t<>\n\t\t\t{isLoading ? (\n\t\t\t\t<p>Loading...</p>\n\t\t\t) : (\n\t\t\t\t<ul>\n\t\t\t\t\t{todos.map((todo) => (\n\t\t\t\t\t\t<li key={todo.id}>{todo.title}</li>\n\t\t\t\t\t))}\n\t\t\t\t</ul>\n\t\t\t)}\n\t\t</>\n\t)\n}\n\nexport default TodoList\n'})}),"\n",(0,s.jsx)(e.p,{children:"Mocking with spyOn the useFetchTodo hook also add tests"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// TodoList.test.tsx\n\nimport { render, screen } from "@testing-library/react"\nimport TodoList from "./TodoList"\nimport * as useFetchTodos from "../../hooks/useFetchTodo/useFetchTodo"\n\ndescribe("TodoList", () => {\n\ttest("should show loading when it is loading", () => {\n\t\t// Arrange\n\t\tconst useFetchTodoSpy = vi.spyOn(useFetchTodos, "default")\n\t\tuseFetchTodoSpy.mockReturnValue({\n\t\t\tisLoading: true,\n\t\t\ttodos: [],\n\t\t})\n\t\trender(<TodoList />)\n\n\t\t// Act & Assert\n\t\texpect(screen.getByText("Loading...")).toBeInTheDocument()\n\n\t\t// Clean\n\t\tuseFetchTodoSpy.mockRestore()\n\t})\n\n\ttest("should show list empty when fetch empty todos", () => {\n\t\t// Arrange\n\t\tconst useFetchTodoSpy = vi.spyOn(useFetchTodos, "default")\n\t\tuseFetchTodoSpy.mockReturnValue({\n\t\t\tisLoading: false,\n\t\t\ttodos: [],\n\t\t})\n\t\trender(<TodoList />)\n\n\t\t// Act & Assert\n\t\texpect(screen.getByRole("list")).toBeInTheDocument()\n\t\texpect(screen.queryAllByRole("listitem")).toHaveLength(0)\n\t})\n\n\ttest("should show list with 2 todo when fetched 2 todos", () => {\n\t\t// Arrange\n\t\tconst useFetchTodoSpy = vi.spyOn(useFetchTodos, "default")\n\t\tuseFetchTodoSpy.mockReturnValue({\n\t\t\tisLoading: false,\n\t\t\ttodos: [\n\t\t\t\t{\n\t\t\t\t\tid: "1",\n\t\t\t\t\ttitle: "Todo 1",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: "2",\n\t\t\t\t\ttitle: "Buy Beer",\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\trender(<TodoList />)\n\n\t\t// Act & Assert\n\t\texpect(screen.getByRole("list")).toBeInTheDocument()\n\t\tconst allItems = screen.queryAllByRole("listitem")\n\t\texpect(allItems).toHaveLength(2)\n\t\texpect(allItems[0]).toHaveTextContent("Todo 1")\n\t\texpect(allItems[1]).toHaveTextContent("Buy Beer")\n\t})\n})\n'})})]})}function h(t={}){const{wrapper:e}={...(0,o.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(d,{...t})}):d(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>r,x:()=>a});var s=n(6540);const o={},i=s.createContext(o);function r(t){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:r(t.components),s.createElement(i.Provider,{value:e},t.children)}}}]);