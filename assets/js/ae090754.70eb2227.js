"use strict";(self.webpackChunkreact_cmu_docs_2024=self.webpackChunkreact_cmu_docs_2024||[]).push([[700],{4679:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(4848),c=t(8453);const o={sidebar_position:1},r="React Hook",i={id:"tutorial-extras/react-hook",title:"React Hook",description:"hook is api provide by react",source:"@site/docs/tutorial-extras/react-hook.md",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/react-hook",permalink:"/mycos-workshop-2024/docs/tutorial-extras/react-hook",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced - Extras",permalink:"/mycos-workshop-2024/docs/category/advanced---extras"},next:{title:"Custom Hook",permalink:"/mycos-workshop-2024/docs/tutorial-extras/custom-hook"}},a={},l=[{value:"useState",id:"usestate",level:2},{value:"how to set state",id:"how-to-set-state",level:3},{value:"useEffect",id:"useeffect",level:2},{value:"Empty array of subscribe",id:"empty-array-of-subscribe",level:2},{value:"Use other state inside useEffect",id:"use-other-state-inside-useeffect",level:2},{value:"useRef",id:"useref",level:2},{value:"useCallback",id:"usecallback",level:2},{value:"useMemo",id:"usememo",level:2},{value:"Other React Hook API",id:"other-react-hook-api",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"react-hook",children:"React Hook"})}),"\n",(0,s.jsx)(n.p,{children:"hook is api provide by react"}),"\n",(0,s.jsx)(n.h2,{id:"usestate",children:"useState"}),"\n",(0,s.jsx)(n.p,{children:"manage state in component, every state change it will cause component re-render with pretty fast (they said)"}),"\n",(0,s.jsx)(n.p,{children:"syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [state, setTheState] = useState<type>(initialValue)\n\n//example\nconst [count, setCount] = useState<number>(0)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-to-set-state",children:"how to set state"}),"\n",(0,s.jsx)(n.p,{children:"We prefer set a state with callback function inside setStateFn"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// BAD\nsetTheState(state + 1)\n\n// GOOD\nsetTheState(previous => previous + 1)\n\n// BAD\nsetToggle(!isShow)\n\n// GOOD\nsetTheState(prev => !prev)\n\n// BAD\nsetMySelfAge({...mySelfState, age: 29 })\n\n// GOOD\nsetMySelfAge(prev => {...prev, age: 29 })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We don't know how different BAD/GOOD yet, but it will be big effect when use inside ",(0,s.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,s.jsx)(n.h2,{id:"useeffect",children:"useEffect"}),"\n",(0,s.jsx)(n.p,{children:"Trigger or called when subscribe state changed"}),"\n",(0,s.jsx)(n.p,{children:"syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"\nuseEffect(() => {\n    // do whatever after state change\n    return () => {\n        // do before next state change\n    }\n\n}, [subscribeState]) // or dependencies\n"})}),"\n",(0,s.jsx)(n.p,{children:"example click to setCount(5)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"    const [count, setCount] = useState(3)\n\n    useEffect(() => {\n        console.log('after count change: ', count)\n\n        return () => {\n            console.log('before count change: ', count)\n        }\n    }, [count])\n\n    // it will be log following\n    // before count change: 3\n    // after count change: 5\n"})}),"\n",(0,s.jsx)(n.h2,{id:"empty-array-of-subscribe",children:"Empty array of subscribe"}),"\n",(0,s.jsx)(n.p,{children:"this purpose for call once when initial component"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"\nuseEffect(() => {\n    // call once when component is created or first render\n    return () => {\n        // call once when component being destroy\n    }\n}, [])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"use-other-state-inside-useeffect",children:"Use other state inside useEffect"}),"\n",(0,s.jsx)(n.p,{children:"The rule is want to use state inside useEffect, we need to add in dependencies array except setState function,"}),"\n",(0,s.jsx)(n.p,{children:"example we have new isShow state which our count can divine by 5 will toggle isShow state"}),"\n",(0,s.jsx)(n.p,{children:"How to do that with useEffect?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [count, setCount] = useState(4)\nconst [isShow, setIsShow] = useState(false)\n// BAD, will cause infinite loop\nuseEffect(() => {\n    \n    if (count % 5 === 0) {\n        setIsShow(!isShow)\n    }\n    console.log('trigger effect')\n}, [count, isShow])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because when the count is 5 will set isShow since we subscribe isShow too, isShow change state it will trigger useEffect then condition still too and continue setIsShow and isShow change trigger useEffect again and so on...\nThat why we prefer setState with callback in previous section"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [count, setCount] = useState(4)\nconst [isShow, setIsShow] = useState(false)\n// GOOD\nuseEffect(() => {\n    \n    if (count % 5 === 0) {\n        setIsShow(prev => prev)\n    }\n    console.log('trigger effect')\n}, [count])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"useref",children:"useRef"}),"\n",(0,s.jsxs)(n.p,{children:["First purpose of useRef it direct accessing DOM element\nand working after ",(0,s.jsx)(n.code,{children:".current"})," only"]}),"\n",(0,s.jsx)(n.p,{children:"example change directly dom background without using state\nsyntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"    const divRef = useRef<HTMLDivElement>(null)\n\n    divRef.current.backgroundColor = 'red'\n\n    return  (\n\t\t<div ref={divRef}>\n        </div>\n    )\n    \n"})}),"\n",(0,s.jsx)(n.p,{children:"Second purpose, useRef not trigger react re-render, so it good to stored some value that we don't want to trigger\nExample want to keep previous count state and doesn't want to trigger re-render"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [count, setCount] = useState(4)\nconst previousCountRef = useRef<number>(null)\n\nuseEffect(() => {\n    return () => {\n        previousCountRef.current = count\n    }\n    \n}, [count])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Another example, keep isShow when count > 5 but don't want to trigger re-render"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [count, setCount] = useState(4)\nconst isShowRef = useRef<boolean>(false)\n\nuseEffect(() => {\n    if (count > 5) {\n        isShowRef.current = true\n    }\n    \n}, [count])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We don't need to register ref to dependencies array but do not forget to set in ",(0,s.jsx)(n.code,{children:".current"})," only"]}),"\n",(0,s.jsx)(n.h2,{id:"usecallback",children:"useCallback"}),"\n",(0,s.jsx)(n.p,{children:"This hook memorize function in React Component, when we need to pass function to another component to avoid unnecessary re-render"}),"\n",(0,s.jsx)(n.p,{children:"We create function use in component it will be fine, but if we want to use this function inside useEffect\nwe need to register in dependencies array and it will cause trigger effect infinite because the same function name but it difference symbol"}),"\n",(0,s.jsx)(n.p,{children:"example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const a = () => {}\nconst b = () => {}\na === b // false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Start like above we create function ",(0,s.jsx)(n.code,{children:"callApiAfterCountEvery5"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\nconst callApiAfterCountEvery5 = () => {\n\t\tconsole.log('call api')\n}\n\nuseEffect(() => {\n    if (count % 5 === 0 && count !== 0) {\n        callApiAfterCountEvery5()\n    }\n}, [callApiAfterCountEvery5, count])\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["unlike ",(0,s.jsx)(n.code,{children:"setState"}),", another function or custom function in component need to register in dependencies array too if we want to use inside useEffect"]}),"\n",(0,s.jsxs)(n.p,{children:["when call ",(0,s.jsx)(n.code,{children:"setCount(5)"})," it called callApiAfterCountEvery5 once\nwhen call ",(0,s.jsx)(n.code,{children:"setCount(10)"})," it called callApiAfterCountEvery5 once again and so on\nit look like working well but if we have another state like ",(0,s.jsx)(n.code,{children:"isShow"})," state but isShow do not subscribe in useEffect"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\nconst [count, setCount] = useState(5)\nconst [isShow, setIsShow] = useState(false)\n\nconst callApiAfterCountEvery5 = () => {\n\t\tconsole.log('call api')\n}\n\nuseEffect(() => {\n    if (count % 5 === 0 && count !== 0) {\n        callApiAfterCountEvery5()\n    }\n}, [callApiAfterCountEvery5, count])\n\n// simulate click isShow\nsetIsShow(prev => !prev)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["it log ",(0,s.jsx)(n.code,{children:"call api"})," now it have problem"]}),"\n",(0,s.jsxs)(n.p,{children:["Because when component re-render it will create new function too even the same name (but it difference symbol like example above) and setIsShow trigger the component re-render\nwe can fix by memo function ",(0,s.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,s.jsx)(n.p,{children:"syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"    const functionName = useCallback(() => {\n\n    }, [stateSubscribe])\n"})}),"\n",(0,s.jsx)(n.p,{children:"like useEffect the function will re-create only state subscribe changed if we create empty subscribe"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const callApiAfterCountEvery5 = useCallback(() => {\n\t\tconsole.log('call api')\n}, [])\n"})}),"\n",(0,s.jsx)(n.p,{children:"it only create once after component created"}),"\n",(0,s.jsx)(n.p,{children:"now it can solve the problem when click setIsShow, it doesn't call api effect"}),"\n",(0,s.jsx)(n.h2,{id:"usememo",children:"useMemo"}),"\n",(0,s.jsx)(n.p,{children:"like useCallback but it for state object or prop object and need to return value"}),"\n",(0,s.jsx)(n.p,{children:"syntax"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const variableName = useMemo(() => {\n    return MemoValue\n}, [stateSubscribe])\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example; If we have some calculation with count but don't want to calculate every re-render"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const countMultiFive = useMemo(() => {\n    return count * 5;\n}, [count])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"countMultiFive"})," will re-created only when count changed, after we click setIsShow, it do nothing."]}),"\n",(0,s.jsx)(n.h2,{id:"other-react-hook-api",children:"Other React Hook API"}),"\n",(0,s.jsx)(n.p,{children:"More hook will helpful but not in this section"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"useDeferredValue"}),"\n",(0,s.jsx)(n.li,{children:"useImperativeHandle"}),"\n",(0,s.jsx)(n.li,{children:"useTransition"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["all hook: ",(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/hooks",children:"https://react.dev/reference/react/hooks"})]})]})}function d(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var s=t(6540);const c={},o=s.createContext(c);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);